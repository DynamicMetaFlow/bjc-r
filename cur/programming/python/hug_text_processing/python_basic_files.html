<!DOCTYPE html>
<html>
    <head>
        <script src="/bjc-r/llab/loader.js"></script>
        <title>Basic File Input</title>
    </head>
    <body>
        <p>
            In this section we will discuss how you can read files in Python. We'll also demo a common pattern in Python programming, where we first create "top level" scripts, that we later move into functions once we feel confident they are working. 
        </p>
        <p>
            To start, create a file called "word_analyzer.py" and open it in your favorite text editor. Once you've got it open, add the following code:
        </p>

    <pre>
      <code>f = open("horse_ebooks.txt", "r")
print(f)
      </code>
    </pre>
      <p>
        In Python, <code>open</code> is a reporter that takes two arguments. The first is the name of the file you want to open, and the second is a "mode", in this case "r" for "read". Don't worry about the details too much in this lab, you'll cover them in a later course. The <code>open</code> reporter reports a file object, which we then store in variable f using the <code>=</code> operator. What is a file object? You can think of it as a magical portal into the file specified, that will let us get information out of files on our computer.
      </p>
        Run this file and you should see something mysterious that looks something like:
      </p>

    <pre>
      <code>$ python word_analyzer.py
<_io.TextIOWrapper name='horse_ebooks.txt' mode='r' encoding='UTF-8'>
      </code>
    </pre>

 <p class="alert quoteBlue">
 Tip: Instead of typing out the entire filename for "word_analyzer.py", instead just type "python wo", then press tab, and your command line will autocomplete the filename. 
 </p>

    <p>Consider that mysterious stuff that got printed out by Python: <code><_io.TextIOWrapper name='horse_ebooks.txt' mode='r' encoding='UTF-8'></code> This is Python's way of printing out the file object. As a programmer, you don't really care (or understand) what this stuff means. It's like asking one of your friends for her DNA sequence instead of asking her to pass you the mashed potatoes. Instead, we want the file object to do its job and get the data from the file on our computer. To do this, modify your word_analyzer.py so that it reads as shown below:

    <pre>
      <code>f = open("horse_ebooks.txt", "r")
text = f.read()
print(text)
      </code>
    </pre>

    <p>
    Try running word_analyzer.py, and you should get a print out of the contents of the file "horse_ebooks.txt".
    </p>

    <pre>
      <code>$ python word_lengths.py
Fruits and Vegetables and Vegetables on a Budget and Vegetables at a Store and Vegetables to Clean Fruit and Vegetables
      </code>
    </pre>

    <p>If we look to the Python code, <code>f.read()</code> is the important part. <code>read</code> is a function that is built into every file object (just like <code>.append</code> is built into any list and <code>.join</code> is built into any string). Here, we're telling the file object (which we said to think of as a magical portal into horse_ebooks.txt) to give us the contents of its corresponding file.
    </p>

    <p>Just like we've done before in Snap<em>!</em>, it makes sense to move code that does specific tasks into a block. In this case, we're going to want to read files throughout the rest of this lab, so we should move our code into a function called <code>read_file</code>. We're doing this because if we want to read many files throughout the lab, we'd rather use a single function rather than have to rewrite these two lines of code every time. T Modify your word_length.py so that it reads as below. 
    </p>

    <pre>
      <code>def read_file(filename):
    """Returns the text contained in file with given filename."""
    f = open("ketchup.txt", "r")
    text = f.read()
    return text</code>
    </pre>

    <p>You'll notice that we've done something strange, and have added an English description of what the function is supposed to do inside triple quotes. These triple quoted comments are very (!!) common in real world Python code, as it provides other programmers with an understanding of what your function is supposed to do.</p>

    <p>Recall that abstraction gives us two glorious advantages: detail hiding and generalization. We've now got a general function that can read any file, and when we read files we don't have to think about file objects or modes or any of that mysterious business. We first saw these principles in action in Snap<em>!</em>, but they'll be important to you as long as you're writing programs, and even beyond. 
    </p>

    </body>
</html>